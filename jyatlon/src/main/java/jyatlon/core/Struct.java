package jyatlon.core;

/**
 *	-----------------------------------------------------------------------------
 *	----          	  GENERATED on Sat Aug 22 13:08:18 EDT 2020              ----
 *	-----------------------------------------------------------------------------
 *	DO NOT EDIT THIS FILE - THIS IS A GENERATED CLASS - YOUR CHANGES WILL BE LOST
 *	-----------------------------------------------------------------------------
 *	You must comply with the following instructions in order to do a modification
 *	in this file. Not doing so will see all your changes erased upon regeneration
 *
 *	What file(s) to edit:
 *		- jyatlon/src/main/antlr4/generated/YATL.g4
 *	
 *	How to generate this file (In Eclipse):
 *		- Run As > Java Application: @link StructGen
 *		- Copy console content into file: jyatlon/src/main/java/jyatlon/core/Struct.java
 *
 *	Generator class:
 *		- @link StructGen
 */

import java.util.List;

public class Struct {
	protected final int from;
	protected final int to;

	public Struct(int from, int to) {
		super();
		this.from = from;
		this.to = to;
	}
	public static class AliasExp extends Struct {
		final List<String> aliasName;
		public AliasExp(int from, int to, List<String> aliasName){
			super(from, to);
			this.aliasName = aliasName;
		}
	}
	public static class ArgExp extends Struct {
		final List<ValueExp> valueExp;
		public ArgExp(int from, int to, List<ValueExp> valueExp){
			super(from, to);
			this.valueExp = valueExp;
		}
	}
	public static class BinaryExp extends Struct {
		final String binaryOp;
		final List<ValueExp> valueExp;
		public BinaryExp(int from, int to, String binaryOp, List<ValueExp> valueExp){
			super(from, to);
			this.binaryOp = binaryOp;
			this.valueExp = valueExp;
		}
	}
	public static class CallExp extends Struct {
		final PathExp pathExp;
		final ArgExp argExp;
		public CallExp(int from, int to, PathExp pathExp, ArgExp argExp){
			super(from, to);
			this.pathExp = pathExp;
			this.argExp = argExp;
		}
	}
	public static class ControlExp extends Struct {
		final String aliasName;
		final String controlOp;
		public ControlExp(int from, int to, String aliasName, String controlOp){
			super(from, to);
			this.aliasName = aliasName;
			this.controlOp = controlOp;
		}
	}
	public static class IfExp extends Struct {
		final LogicalExp logicalExp;
		public IfExp(int from, int to, LogicalExp logicalExp){
			super(from, to);
			this.logicalExp = logicalExp;
		}
	}
	public static class Line extends Struct {
		final List<LineExp> lineExp;
		public Line(int from, int to, List<LineExp> lineExp){
			super(from, to);
			this.lineExp = lineExp;
		}
	}
	public static class LineExp extends Struct {
		final Value value;
		final String commentOp;
		final ControlExp controlExp;
		final String escapedChar;
		final String rawText;
		public LineExp(int from, int to, Value value, String commentOp, ControlExp controlExp, String escapedChar, String rawText){
			super(from, to);
			this.value = value;
			this.commentOp = commentOp;
			this.controlExp = controlExp;
			this.escapedChar = escapedChar;
			this.rawText = rawText;
		}
	}
	public static class LogicalExp extends Struct {
		final List<BinaryExp> binaryExp;
		final List<String> logicalOp;
		final List<LogicalExp> logicalExp;
		public LogicalExp(int from, int to, List<BinaryExp> binaryExp, List<String> logicalOp, List<LogicalExp> logicalExp){
			super(from, to);
			this.binaryExp = binaryExp;
			this.logicalOp = logicalOp;
			this.logicalExp = logicalExp;
		}
	}
	public static class Operation extends Struct {
		final String methodName;
		final String aliasName;
		final ArgExp argExp;
		public Operation(int from, int to, String methodName, String aliasName, ArgExp argExp){
			super(from, to);
			this.methodName = methodName;
			this.aliasName = aliasName;
			this.argExp = argExp;
		}
	}
	public static class PathArg extends Struct {
		final String aliasName;
		final String pathName;
		public PathArg(int from, int to, String aliasName, String pathName){
			super(from, to);
			this.aliasName = aliasName;
			this.pathName = pathName;
		}
	}
	public static class PathExp extends Struct {
		final String anyPathOp;
		final List<PathArg> pathArg;
		public PathExp(int from, int to, String anyPathOp, List<PathArg> pathArg){
			super(from, to);
			this.anyPathOp = anyPathOp;
			this.pathArg = pathArg;
		}
	}
	public static class Section extends Struct {
		final PathExp pathExp;
		final List<String> commentOp;
		final List<String> rawText;
		final AliasExp aliasExp;
		final List<Line> line;
		public Section(int from, int to, PathExp pathExp, List<String> commentOp, List<String> rawText, AliasExp aliasExp, List<Line> line){
			super(from, to);
			this.pathExp = pathExp;
			this.commentOp = commentOp;
			this.rawText = rawText;
			this.aliasExp = aliasExp;
			this.line = line;
		}
	}
	public static class Template extends Struct {
		final List<Section> section;
		public Template(int from, int to, List<Section> section){
			super(from, to);
			this.section = section;
		}
	}
	public static class Value extends Struct {
		final CallExp callExp;
		final ValueExp valueExp;
		final IfExp ifExp;
		public Value(int from, int to, CallExp callExp, ValueExp valueExp, IfExp ifExp){
			super(from, to);
			this.callExp = callExp;
			this.valueExp = valueExp;
			this.ifExp = ifExp;
		}
	}
	public static class ValueExp extends Struct {
		final String aliasName;
		final String unaryOp;
		final String valueArg;
		final List<Operation> operation;
		public ValueExp(int from, int to, String aliasName, String unaryOp, String valueArg, List<Operation> operation){
			super(from, to);
			this.aliasName = aliasName;
			this.unaryOp = unaryOp;
			this.valueArg = valueArg;
			this.operation = operation;
		}
	}
}

