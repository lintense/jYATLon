package jyatlon.core;

/**
 *	-----------------------------------------------------------------------------
 *	----          	  GENERATED on Mon Aug 17 14:09:12 EDT 2020              ----
 *	-----------------------------------------------------------------------------
 *	DO NOT EDIT THIS FILE - THIS IS A GENERATED CLASS - YOUR CHANGES WILL BE LOST
 *	-----------------------------------------------------------------------------
 *	You must comply with the following instructions in order to do a modification
 *	in this file. Not doing so will see all your changes erased upon regeneration
 *
 *	What file(s) to edit:
 *		- jyatlon/src/main/antlr4/generated/YATL.g4
 *	
 *	How to generate this file (In Eclipse):
 *		- Run As > Java Application: @link StructGen
 *		- Copy console content into file: jyatlon/src/main/java/jyatlon/core/Struct.java
 *
 *	Generator class:
 *		- @link StructGen
 */

import java.util.List;

public class Struct {
	protected final int from;
	protected final int to;

	public Struct(int from, int to) {
		super();
		this.from = from;
		this.to = to;
	}
	public static class ArgExp extends Struct {
		final List<ValueExp> valueExp;
		public ArgExp(int from, int to, List<ValueExp> valueExp){
			super(from, to);
			this.valueExp = valueExp;
		}
	}
	public static class BinaryExp extends Struct {
		final String binaryOp;
		final List<ValueExp> valueExp;
		public BinaryExp(int from, int to, String binaryOp, List<ValueExp> valueExp){
			super(from, to);
			this.binaryOp = binaryOp;
			this.valueExp = valueExp;
		}
	}
	public static class CallExp extends Struct {
		final PathExp pathExp;
		public CallExp(int from, int to, PathExp pathExp){
			super(from, to);
			this.pathExp = pathExp;
		}
	}
	public static class ControlExp extends Struct {
		final String aliasName;
		final String controlOp;
		public ControlExp(int from, int to, String aliasName, String controlOp){
			super(from, to);
			this.aliasName = aliasName;
			this.controlOp = controlOp;
		}
	}
	public static class IfExp extends Struct {
		final LogicalExp logicalExp;
		public IfExp(int from, int to, LogicalExp logicalExp){
			super(from, to);
			this.logicalExp = logicalExp;
		}
	}
	public static class Line extends Struct {
		final List<LineExp> lineExp;
		public Line(int from, int to, List<LineExp> lineExp){
			super(from, to);
			this.lineExp = lineExp;
		}
	}
	public static class LineExp extends Struct {
		final Value value;
		final ControlExp controlExp;
		final String rawText;
		final String escapedChar;
		final String commentOp;
		public LineExp(int from, int to, Value value, ControlExp controlExp, String rawText, String escapedChar, String commentOp){
			super(from, to);
			this.value = value;
			this.controlExp = controlExp;
			this.rawText = rawText;
			this.escapedChar = escapedChar;
			this.commentOp = commentOp;
		}
	}
	public static class LogicalExp extends Struct {
		final List<LogicalExp> logicalExp;
		final List<BinaryExp> binaryExp;
		final List<String> logicalOp;
		public LogicalExp(int from, int to, List<LogicalExp> logicalExp, List<BinaryExp> binaryExp, List<String> logicalOp){
			super(from, to);
			this.logicalExp = logicalExp;
			this.binaryExp = binaryExp;
			this.logicalOp = logicalOp;
		}
	}
	public static class Operation extends Struct {
		final String methodName;
		final String aliasName;
		final ArgExp argExp;
		public Operation(int from, int to, String methodName, String aliasName, ArgExp argExp){
			super(from, to);
			this.methodName = methodName;
			this.aliasName = aliasName;
			this.argExp = argExp;
		}
	}
	public static class PathArg extends Struct {
		final String aliasName;
		final String pathName;
		public PathArg(int from, int to, String aliasName, String pathName){
			super(from, to);
			this.aliasName = aliasName;
			this.pathName = pathName;
		}
	}
	public static class PathExp extends Struct {
		final List<PathArg> pathArg;
		final String anyPathOp;
		public PathExp(int from, int to, List<PathArg> pathArg, String anyPathOp){
			super(from, to);
			this.pathArg = pathArg;
			this.anyPathOp = anyPathOp;
		}
	}
	public static class Section extends Struct {
		final PathExp pathExp;
		final List<Line> line;
		final List<String> rawText;
		final List<String> commentOp;
		public Section(int from, int to, PathExp pathExp, List<Line> line, List<String> rawText, List<String> commentOp){
			super(from, to);
			this.pathExp = pathExp;
			this.line = line;
			this.rawText = rawText;
			this.commentOp = commentOp;
		}
	}
	public static class Template extends Struct {
		final List<Section> section;
		public Template(int from, int to, List<Section> section){
			super(from, to);
			this.section = section;
		}
	}
	public static class Value extends Struct {
		final IfExp ifExp;
		final CallExp callExp;
		final ValueExp valueExp;
		public Value(int from, int to, IfExp ifExp, CallExp callExp, ValueExp valueExp){
			super(from, to);
			this.ifExp = ifExp;
			this.callExp = callExp;
			this.valueExp = valueExp;
		}
	}
	public static class ValueExp extends Struct {
		final String aliasName;
		final List<Operation> operation;
		final String unaryOp;
		final String valueArg;
		public ValueExp(int from, int to, String aliasName, List<Operation> operation, String unaryOp, String valueArg){
			super(from, to);
			this.aliasName = aliasName;
			this.operation = operation;
			this.unaryOp = unaryOp;
			this.valueArg = valueArg;
		}
	}
}

